const express = require('express');
const router = express.Router();

// Generate GPX file from route data
router.post('/generate', async (req, res) => {
  try {
    const { route, network, startPoint, endPoint, routeName = 'Optimized Route' } = req.body;
    
    const gpxContent = generateGPX(route, network, startPoint, endPoint, routeName);
    
    res.set({
      'Content-Type': 'application/gpx+xml',
      'Content-Disposition': `attachment; filename="${routeName.replace(/[^a-zA-Z0-9]/g, '_')}.gpx"`
    });
    
    res.send(gpxContent);
  } catch (error) {
    console.error('Error generating GPX:', error);
    res.status(500).json({ error: 'Failed to generate GPX file' });
  }
});

// Generate GPX content
function generateGPX(route, network, startPoint, endPoint, routeName) {
  const nodes = new Map();
  network.nodes.forEach(node => {
    nodes.set(node.id, node);
  });
  
  // Build track points from route
  const trackPoints = [];
  
  // Add start point if specified
  if (startPoint && startPoint.lat && startPoint.lon) {
    trackPoints.push({
      lat: startPoint.lat,
      lon: startPoint.lon,
      name: 'Start Point'
    });
  }
  
  // Add route points
  route.forEach(segment => {
    const fromNode = nodes.get(segment.from);
    const toNode = nodes.get(segment.to);
    
    if (fromNode && toNode) {
      // Add intermediate points if this is a multi-node segment
      if (segment.intermediatePoints && segment.intermediatePoints.length > 0) {
        segment.intermediatePoints.forEach(point => {
          trackPoints.push({
            lat: point.lat,
            lon: point.lon
          });
        });
      } else {
        // Add start and end of segment
        trackPoints.push({
          lat: fromNode.lat,
          lon: fromNode.lon
        });
        trackPoints.push({
          lat: toNode.lat,
          lon: toNode.lon
        });
      }
    }
  });
  
  // Add end point if specified
  if (endPoint && endPoint.lat && endPoint.lon) {
    trackPoints.push({
      lat: endPoint.lat,
      lon: endPoint.lon,
      name: 'End Point'
    });
  }
  
  // Remove duplicate consecutive points
  const uniquePoints = [];
  for (let i = 0; i < trackPoints.length; i++) {
    if (i === 0 || 
        trackPoints[i].lat !== trackPoints[i-1].lat || 
        trackPoints[i].lon !== trackPoints[i-1].lon) {
      uniquePoints.push(trackPoints[i]);
    }
  }
  
  return createGPXContent(uniquePoints, routeName);
}

// Create GPX XML content
function createGPXContent(trackPoints, routeName) {
  const now = new Date().toISOString();
  
  let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Strava Route Optimizer" xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">
  <metadata>
    <name>${escapeXML(routeName)}</name>
    <desc>Optimized route generated by Strava Route Optimizer</desc>
    <time>${now}</time>
  </metadata>
  <trk>
    <name>${escapeXML(routeName)}</name>
    <trkseg>`;
  
  trackPoints.forEach(point => {
    gpx += `
      <trkpt lat="${point.lat}" lon="${point.lon}">`;
    
    if (point.name) {
      gpx += `
        <name>${escapeXML(point.name)}</name>`;
    }
    
    gpx += `
      </trkpt>`;
  });
  
  gpx += `
    </trkseg>
  </trk>
</gpx>`;
  
  return gpx;
}

// Escape XML special characters
function escapeXML(text) {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

// Generate GPX from Strava activity
router.post('/from-strava', async (req, res) => {
  try {
    const { activityId, accessToken } = req.body;
    
    // Fetch GPX from Strava
    const response = await fetch(`https://www.strava.com/api/v3/activities/${activityId}/export_gpx`, {
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    });
    
    if (!response.ok) {
      throw new Error('Failed to fetch GPX from Strava');
    }
    
    const gpxContent = await response.text();
    
    res.set({
      'Content-Type': 'application/gpx+xml',
      'Content-Disposition': `attachment; filename="strava_activity_${activityId}.gpx"`
    });
    
    res.send(gpxContent);
  } catch (error) {
    console.error('Error fetching Strava GPX:', error);
    res.status(500).json({ error: 'Failed to fetch GPX from Strava' });
  }
});

// Generate GPX with waypoints
router.post('/with-waypoints', async (req, res) => {
  try {
    const { route, network, startPoint, endPoint, waypoints, routeName = 'Route with Waypoints' } = req.body;
    
    const gpxContent = generateGPXWithWaypoints(route, network, startPoint, endPoint, waypoints, routeName);
    
    res.set({
      'Content-Type': 'application/gpx+xml',
      'Content-Disposition': `attachment; filename="${routeName.replace(/[^a-zA-Z0-9]/g, '_')}.gpx"`
    });
    
    res.send(gpxContent);
  } catch (error) {
    console.error('Error generating GPX with waypoints:', error);
    res.status(500).json({ error: 'Failed to generate GPX file with waypoints' });
  }
});

// Generate GPX content with waypoints
function generateGPXWithWaypoints(route, network, startPoint, endPoint, waypoints, routeName) {
  const nodes = new Map();
  network.nodes.forEach(node => {
    nodes.set(node.id, node);
  });
  
  // Build track points from route
  const trackPoints = [];
  
  // Add start point if specified
  if (startPoint && startPoint.lat && startPoint.lon) {
    trackPoints.push({
      lat: startPoint.lat,
      lon: startPoint.lon,
      name: 'Start Point'
    });
  }
  
  // Add route points
  route.forEach(segment => {
    const fromNode = nodes.get(segment.from);
    const toNode = nodes.get(segment.to);
    
    if (fromNode && toNode) {
      trackPoints.push({
        lat: fromNode.lat,
        lon: fromNode.lon
      });
      trackPoints.push({
        lat: toNode.lat,
        lon: toNode.lon
      });
    }
  });
  
  // Add end point if specified
  if (endPoint && endPoint.lat && endPoint.lon) {
    trackPoints.push({
      lat: endPoint.lat,
      lon: endPoint.lon,
      name: 'End Point'
    });
  }
  
  // Remove duplicate consecutive points
  const uniquePoints = [];
  for (let i = 0; i < trackPoints.length; i++) {
    if (i === 0 || 
        trackPoints[i].lat !== trackPoints[i-1].lat || 
        trackPoints[i].lon !== trackPoints[i-1].lon) {
      uniquePoints.push(trackPoints[i]);
    }
  }
  
  return createGPXWithWaypointsContent(uniquePoints, waypoints, routeName);
}

// Create GPX XML content with waypoints
function createGPXWithWaypointsContent(trackPoints, waypoints, routeName) {
  const now = new Date().toISOString();
  
  let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Strava Route Optimizer" xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">
  <metadata>
    <name>${escapeXML(routeName)}</name>
    <desc>Optimized route with waypoints generated by Strava Route Optimizer</desc>
    <time>${now}</time>
  </metadata>`;
  
  // Add waypoints
  if (waypoints && waypoints.length > 0) {
    waypoints.forEach((waypoint, index) => {
      gpx += `
  <wpt lat="${waypoint.lat}" lon="${waypoint.lon}">
    <name>${escapeXML(waypoint.name || `Waypoint ${index + 1}`)}</name>
    <desc>${escapeXML(waypoint.description || 'Route waypoint')}</desc>
  </wpt>`;
    });
  }
  
  // Add track
  gpx += `
  <trk>
    <name>${escapeXML(routeName)}</name>
    <trkseg>`;
  
  trackPoints.forEach(point => {
    gpx += `
      <trkpt lat="${point.lat}" lon="${point.lon}">`;
    
    if (point.name) {
      gpx += `
        <name>${escapeXML(point.name)}</name>`;
    }
    
    gpx += `
      </trkpt>`;
  });
  
  gpx += `
    </trkseg>
  </trk>
</gpx>`;
  
  return gpx;
}

module.exports = router; 